/**
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 0.1
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require("request");
import http = require("http");

let defaultBasePath = "http://localhost/api/v0/registry/";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

/**
 * A type of aspect in the registry.
 */
export class AspectDefinition {
    /**
     * The unique identifier for the aspect type.
     */
    "id": string;
    /**
     * The name of the aspect.
     */
    "name": string;
    /**
     * The JSON Schema of this aspect.
     */
    "jsonSchema": any;
}

export class BadRequest {
    "message": string;
}

export class CountResponse {
    "count": number;
}

export class DeleteResult {
    "deleted": boolean;
}

/**
 * The type of a registry modification event.
 */
export type EventType =
    | "CreateRecord"
    | "CreateAspectDefinition"
    | "CreateRecordAspect"
    | "PatchRecord"
    | "PatchAspectDefinition"
    | "PatchRecordAspect"
    | "DeleteRecord"
    | "DeleteAspectDefinition"
    | "DeleteRecordAspect";

/**
 * A page of events.
 */
export class EventsPage {
    /**
     * Whether there are more events available.
     */
    "hasMore": boolean;
    /**
     * A token to be used to get the next page of events.
     */
    "nextPageToken": string;
    /**
     * The events in this page.
     */
    "events": Array<RegistryEvent>;
}

export class JsObject {
    "fields": { [key: string]: JsValue };
}

export class JsValue {}

export class MultipleDeleteResult {
    "count": number;
}

export class Operation {}

/**
 * A record in the registry, usually including data for one or more aspects.
 */
export class Record {
    /**
     * The unique identifier of the record
     */
    "id": string;
    /**
     * The name of the record
     */
    "name": string;
    /**
     * The aspects included in this record
     */
    "aspects": any;
    /**
     * A tag representing the action by the source of this record (e.g. an id for a individual crawl of a data portal).
     */
    "sourceTag": string;
}

/**
 * A summary of a record in the registry.  Summaries specify which aspects are available, but do not include data for any aspects.
 */
export class RecordSummary {
    /**
     * The unique identifier of the record
     */
    "id": string;
    /**
     * The name of the record
     */
    "name": string;
    /**
     * The list of aspect IDs for which this record has data
     */
    "aspects": Array<string>;
}

export class RegistryEvent {
    "id": any;
    "eventTime": Date;
    "eventType": EventType;
    "userId": number;
    "data": JsObject;
}

export class WebHook {
    "id": string;
    "userId": any;
    "name": string;
    "active": boolean;
    "lastEvent": any;
    "url": string;
    "eventTypes": Array<EventType>;
    "isWaitingForResponse": any;
    "config": WebHookConfig;
    "enabled": boolean;
    "lastRetryTime": Date;
    "retryCount": number;
    "isRunning": any;
    "isProcessing": any;
}

/**
 * Asynchronously acknowledges receipt of a web hook notification.
 */
export class WebHookAcknowledgement {
    /**
     * True if the web hook was received successfully and the listener is ready for further notifications.  False if the web hook was not received and the same notification should be repeated.
     */
    "succeeded": boolean;
    /**
     * The ID of the last event received by the listener.  This should be the value of the `lastEventId` property of the web hook payload that is being acknowledged.  This value is ignored if `succeeded` is false.
     */
    "lastEventIdReceived": any;
    /**
     * Should the webhook be active or inactive?
     */
    "active": any;
}

/**
 * The response to an asynchronous web hook acknowledgement.
 */
export class WebHookAcknowledgementResponse {
    /**
     * The ID of the last event successfully received by the listener.  Further notifications will start after this event.
     */
    "lastEventIdReceived": number;
}

export class WebHookConfig {
    "aspects": Array<string>;
    "optionalAspects": Array<string>;
    "includeEvents": any;
    "includeRecords": any;
    "includeAspectDefinitions": any;
    "dereference": any;
}

export interface Authentication {
    /**
     * Apply authentication settings to header and query params.
     */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username,
            password: this.password
        };
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {}

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (
            this.location == "header" &&
            requestOptions &&
            requestOptions.headers
        ) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] =
                "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum AspectDefinitionsApiApiKeys {}

export class AspectDefinitionsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications: any = {
        default: <Authentication>new VoidAuth()
    };

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: AspectDefinitionsApiApiKeys, value: string) {
        this.authentications[AspectDefinitionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new aspect
     *
     * @param aspect The definition of the new aspect.
     * @param xMagdaSession Magda internal session id
     */
    public create(
        aspect: AspectDefinition,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: AspectDefinition }> {
        const localVarPath = this.basePath + "/aspects";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'aspect' is not null or undefined
        if (aspect === null || aspect === undefined) {
            throw new Error(
                "Required parameter aspect was null or undefined when calling create."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling create."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aspect
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: AspectDefinition;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all aspects
     *
     */
    public getAll(): Promise<{
        response: http.IncomingMessage;
        body: Array<AspectDefinition>;
    }> {
        const localVarPath = this.basePath + "/aspects";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<AspectDefinition>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get an aspect by ID
     *
     * @param id ID of the aspect to be fetched.
     */
    public getById(
        id: string
    ): Promise<{ response: http.IncomingMessage; body: AspectDefinition }> {
        const localVarPath =
            this.basePath +
            "/aspects/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling getById."
            );
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: AspectDefinition;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modify an aspect by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param id ID of the aspect to be saved.
     * @param aspectPatch The RFC 6902 patch to apply to the aspect.
     * @param xMagdaSession Magda internal session id
     */
    public patchById(
        id: string,
        aspectPatch: Array<Operation>,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: AspectDefinition }> {
        const localVarPath =
            this.basePath +
            "/aspects/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'aspectPatch' is not null or undefined
        if (aspectPatch === null || aspectPatch === undefined) {
            throw new Error(
                "Required parameter aspectPatch was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling patchById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PATCH",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aspectPatch
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: AspectDefinition;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modify an aspect by ID
     * Modifies the aspect with a given ID.  If an aspect with the ID does not yet exist, it is created.
     * @param id ID of the aspect to be saved.
     * @param aspect The aspect to save.
     * @param xMagdaSession Magda internal session id
     */
    public putById(
        id: string,
        aspect: AspectDefinition,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: AspectDefinition }> {
        const localVarPath =
            this.basePath +
            "/aspects/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling putById."
            );
        }

        // verify required parameter 'aspect' is not null or undefined
        if (aspect === null || aspect === undefined) {
            throw new Error(
                "Required parameter aspect was null or undefined when calling putById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling putById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aspect
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: AspectDefinition;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum RecordAspectsApiApiKeys {}

export class RecordAspectsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications: any = {
        default: <Authentication>new VoidAuth()
    };

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: RecordAspectsApiApiKeys, value: string) {
        this.authentications[RecordAspectsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Delete a record aspect by ID
     * Deletes a record aspect.
     * @param recordId ID of the record for which to delete an aspect.
     * @param aspectId ID of the aspect to delete.
     * @param xMagdaSession Magda internal session id
     */
    public deleteById(
        recordId: string,
        aspectId: string,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: DeleteResult }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/aspects/{aspectId}"
                .replace("{" + "recordId" + "}", String(recordId))
                .replace("{" + "aspectId" + "}", String(aspectId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling deleteById."
            );
        }

        // verify required parameter 'aspectId' is not null or undefined
        if (aspectId === null || aspectId === undefined) {
            throw new Error(
                "Required parameter aspectId was null or undefined when calling deleteById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling deleteById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: DeleteResult;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a record aspect by ID
     *
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     */
    public getById(
        recordId: string,
        aspectId: string
    ): Promise<{ response: http.IncomingMessage; body: any }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/aspects/{aspectId}"
                .replace("{" + "recordId" + "}", String(recordId))
                .replace("{" + "aspectId" + "}", String(aspectId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling getById."
            );
        }

        // verify required parameter 'aspectId' is not null or undefined
        if (aspectId === null || aspectId === undefined) {
            throw new Error(
                "Required parameter aspectId was null or undefined when calling getById."
            );
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Modify a record aspect by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param recordId ID of the record for which to fetch an aspect.
     * @param aspectId ID of the aspect to fetch.
     * @param aspectPatch The RFC 6902 patch to apply to the aspect.
     * @param xMagdaSession Magda internal session id
     */
    public patchById(
        recordId: string,
        aspectId: string,
        aspectPatch: Array<Operation>,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: any }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/aspects/{aspectId}"
                .replace("{" + "recordId" + "}", String(recordId))
                .replace("{" + "aspectId" + "}", String(aspectId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'aspectId' is not null or undefined
        if (aspectId === null || aspectId === undefined) {
            throw new Error(
                "Required parameter aspectId was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'aspectPatch' is not null or undefined
        if (aspectPatch === null || aspectPatch === undefined) {
            throw new Error(
                "Required parameter aspectPatch was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling patchById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PATCH",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aspectPatch
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Modify a record aspect by ID
     * Modifies a record aspect.  If the aspect does not yet exist on this record, it is created.
     * @param recordId ID of the record for which to update an aspect.
     * @param aspectId ID of the aspect to update.
     * @param aspect The record aspect to save.
     * @param xMagdaSession Magda internal session id
     */
    public putById(
        recordId: string,
        aspectId: string,
        aspect: any,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: any }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/aspects/{aspectId}"
                .replace("{" + "recordId" + "}", String(recordId))
                .replace("{" + "aspectId" + "}", String(aspectId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling putById."
            );
        }

        // verify required parameter 'aspectId' is not null or undefined
        if (aspectId === null || aspectId === undefined) {
            throw new Error(
                "Required parameter aspectId was null or undefined when calling putById."
            );
        }

        // verify required parameter 'aspect' is not null or undefined
        if (aspect === null || aspect === undefined) {
            throw new Error(
                "Required parameter aspect was null or undefined when calling putById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling putById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: aspect
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: any }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
}
export enum RecordHistoryApiApiKeys {}

export class RecordHistoryApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications: any = {
        default: <Authentication>new VoidAuth()
    };

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: RecordHistoryApiApiKeys, value: string) {
        this.authentications[RecordHistoryApiApiKeys[key]].apiKey = value;
    }
    /**
     * Get a list of all events affecting this record
     *
     * @param recordId ID of the record for which to fetch history.
     */
    public history(
        recordId: string
    ): Promise<{ response: http.IncomingMessage; body: EventsPage }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/history".replace(
                "{" + "recordId" + "}",
                String(recordId)
            );
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling history."
            );
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: EventsPage;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the version of a record that existed after a given event was applied
     *
     * @param recordId ID of the record to fetch.
     * @param eventId The ID of the last event to be applied to the record.  The event with this ID need not actually apply to the record, in which case that last event prior to this even that does apply will be used.
     */
    public version(
        recordId: string,
        eventId: string
    ): Promise<{ response: http.IncomingMessage; body: Record }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}/history/{eventId}"
                .replace("{" + "recordId" + "}", String(recordId))
                .replace("{" + "eventId" + "}", String(eventId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling version."
            );
        }

        // verify required parameter 'eventId' is not null or undefined
        if (eventId === null || eventId === undefined) {
            throw new Error(
                "Required parameter eventId was null or undefined when calling version."
            );
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Record }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
}
export enum RecordsApiApiKeys {}

export class RecordsApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications: any = {
        default: <Authentication>new VoidAuth()
    };

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: RecordsApiApiKeys, value: string) {
        this.authentications[RecordsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Create a new record
     *
     * @param record The definition of the new record.
     * @param xMagdaSession Magda internal session id
     */
    public create(
        record: Record,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: Record }> {
        const localVarPath = this.basePath + "/records";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error(
                "Required parameter record was null or undefined when calling create."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling create."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: record
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Record }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Delete a record
     *
     * @param recordId ID of the record to delete.
     * @param xMagdaSession Magda internal session id
     */
    public deleteById(
        recordId: string,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: DeleteResult }> {
        const localVarPath =
            this.basePath +
            "/records/{recordId}".replace(
                "{" + "recordId" + "}",
                String(recordId)
            );
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'recordId' is not null or undefined
        if (recordId === null || recordId === undefined) {
            throw new Error(
                "Required parameter recordId was null or undefined when calling deleteById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling deleteById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: DeleteResult;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all records
     *
     * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have all of these aspects will be included in the response.
     * @param optionalAspect The optional aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  These aspects will be included in a record if available, but a record will be included even if it is missing these aspects.
     * @param pageToken A token that identifies the start of a page of results.  This token should not be interpreted as having any meaning, but it can be obtained from a previous page of results.
     * @param start The index of the first record to retrieve.  When possible, specify pageToken instead as it will result in better performance.  If this parameter and pageToken are both specified, this parameter is interpreted as the index after the pageToken of the first record to retrieve.
     * @param limit The maximum number of records to receive.  The response will include a token that can be passed as the pageToken parameter to a future request to continue receiving results where this query leaves off.
     * @param dereference true to automatically dereference links to other records; false to leave them as links.  Dereferencing a link means including the record itself where the link would be.  Dereferencing only happens one level deep, regardless of the value of this parameter.
     * @param aspectQuery Filter the records returned by a value within the aspect JSON. Expressed as &#39;aspectId.path.to.field:value&#39;, url encoded. NOTE: This is an early stage API and may change greatly in the future
     */
    public getAll(
        aspect?: Array<string>,
        optionalAspect?: Array<string>,
        pageToken?: string,
        start?: number,
        limit?: number,
        dereference?: boolean,
        aspectQuery?: Array<string>
    ): Promise<{ response: http.IncomingMessage; body: Array<Record> }> {
        const localVarPath = this.basePath + "/records";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        if (aspect !== undefined) {
            queryParameters["aspect"] = aspect;
        }

        if (optionalAspect !== undefined) {
            queryParameters["optionalAspect"] = optionalAspect;
        }

        if (pageToken !== undefined) {
            queryParameters["pageToken"] = pageToken;
        }

        if (start !== undefined) {
            queryParameters["start"] = start;
        }

        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }

        if (dereference !== undefined) {
            queryParameters["dereference"] = dereference;
        }

        if (aspectQuery !== undefined) {
            queryParameters["aspectQuery"] = aspectQuery;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<Record>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all records as summaries
     *
     * @param pageToken A token that identifies the start of a page of results.  This token should not be interpreted as having any meaning, but it can be obtained from a previous page of results.
     * @param start The index of the first record to retrieve.  When possible, specify pageToken instead as it will result in better performance.  If this parameter and pageToken are both specified, this parameter is interpreted as the index after the pageToken of the first record to retrieve.
     * @param limit The maximum number of records to receive.  The response will include a token that can be passed as the pageToken parameter to a future request to continue receiving results where this query leaves off.
     */
    public getAllSummary(
        pageToken?: string,
        start?: number,
        limit?: number
    ): Promise<{ response: http.IncomingMessage; body: Array<RecordSummary> }> {
        const localVarPath = this.basePath + "/records/summary";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        if (pageToken !== undefined) {
            queryParameters["pageToken"] = pageToken;
        }

        if (start !== undefined) {
            queryParameters["start"] = start;
        }

        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<RecordSummary>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a record by ID
     * Gets a complete record, including data for all aspects.
     * @param id ID of the record to be fetched.
     * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have all of these aspects will be included in the response.
     * @param optionalAspect The optional aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  These aspects will be included in a record if available, but a record will be included even if it is missing these aspects.
     * @param dereference true to automatically dereference links to other records; false to leave them as links.  Dereferencing a link means including the record itself where the link would be.  Dereferencing only happens one level deep, regardless of the value of this parameter.
     */
    public getById(
        id: string,
        aspect?: Array<string>,
        optionalAspect?: Array<string>,
        dereference?: boolean
    ): Promise<{ response: http.IncomingMessage; body: Record }> {
        const localVarPath =
            this.basePath +
            "/records/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling getById."
            );
        }

        if (aspect !== undefined) {
            queryParameters["aspect"] = aspect;
        }

        if (optionalAspect !== undefined) {
            queryParameters["optionalAspect"] = optionalAspect;
        }

        if (dereference !== undefined) {
            queryParameters["dereference"] = dereference;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Record }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Get a summary record by ID
     * Gets a summary record, including all the aspect ids for which this record has data.
     * @param id ID of the record to be fetched.
     */
    public getByIdSummary(
        id: string
    ): Promise<{ response: http.IncomingMessage; body: RecordSummary }> {
        const localVarPath =
            this.basePath +
            "/records/summary/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling getByIdSummary."
            );
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: RecordSummary;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get the count of records matching the parameters. If no parameters are specified, the count will be approximate for performance reasons.
     *
     * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have all of these aspects will be included in the response.
     * @param aspectQuery Filter the records returned by a value within the aspect JSON. Expressed as &#39;aspectId.path.to.field:value&#39;, url encoded. NOTE: This is an early stage API and may change greatly in the future
     */
    public getCount(
        aspect?: Array<string>,
        aspectQuery?: Array<string>
    ): Promise<{ response: http.IncomingMessage; body: CountResponse }> {
        const localVarPath = this.basePath + "/records/count";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        if (aspect !== undefined) {
            queryParameters["aspect"] = aspect;
        }

        if (aspectQuery !== undefined) {
            queryParameters["aspectQuery"] = aspectQuery;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: CountResponse;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list tokens for paging through the records
     *
     * @param aspect The aspects for which to retrieve data, specified as multiple occurrences of this query parameter.  Only records that have all of these aspects will be included in the response.
     * @param limit The size of each page to get tokens for.
     */
    public getPageTokens(
        aspect?: Array<string>,
        limit?: number
    ): Promise<{ response: http.IncomingMessage; body: Array<string> }> {
        const localVarPath = this.basePath + "/records/pagetokens";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        if (aspect !== undefined) {
            queryParameters["aspect"] = aspect;
        }

        if (limit !== undefined) {
            queryParameters["limit"] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<string>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modify a record by applying a JSON Patch
     * The patch should follow IETF RFC 6902 (https://tools.ietf.org/html/rfc6902).
     * @param id ID of the aspect to be saved.
     * @param recordPatch The RFC 6902 patch to apply to the aspect.
     * @param xMagdaSession Magda internal session id
     */
    public patchById(
        id: string,
        recordPatch: Array<Operation>,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: AspectDefinition }> {
        const localVarPath =
            this.basePath +
            "/records/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'recordPatch' is not null or undefined
        if (recordPatch === null || recordPatch === undefined) {
            throw new Error(
                "Required parameter recordPatch was null or undefined when calling patchById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling patchById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PATCH",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: recordPatch
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: AspectDefinition;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Modify a record by ID
     * Modifies a record.  Aspects included in the request are created or updated, but missing aspects are not removed.
     * @param id ID of the record to be fetched.
     * @param record The record to save.
     * @param xMagdaSession Magda internal session id
     */
    public putById(
        id: string,
        record: Record,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: Record }> {
        const localVarPath =
            this.basePath +
            "/records/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling putById."
            );
        }

        // verify required parameter 'record' is not null or undefined
        if (record === null || record === undefined) {
            throw new Error(
                "Required parameter record was null or undefined when calling putById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling putById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: record
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: Record }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Trim by source tag
     * Trims records with the provided source that DON&#39;T have the supplied source tag
     * @param sourceTagToPreserve Source tag of the records to PRESERVE.
     * @param sourceId Source id of the records to delete.
     * @param xMagdaSession Magda internal session id
     */
    public trimBySourceTag(
        sourceTagToPreserve: string,
        sourceId: string,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: MultipleDeleteResult }> {
        const localVarPath = this.basePath + "/records";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'sourceTagToPreserve' is not null or undefined
        if (sourceTagToPreserve === null || sourceTagToPreserve === undefined) {
            throw new Error(
                "Required parameter sourceTagToPreserve was null or undefined when calling trimBySourceTag."
            );
        }

        // verify required parameter 'sourceId' is not null or undefined
        if (sourceId === null || sourceId === undefined) {
            throw new Error(
                "Required parameter sourceId was null or undefined when calling trimBySourceTag."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling trimBySourceTag."
            );
        }

        if (sourceTagToPreserve !== undefined) {
            queryParameters["sourceTagToPreserve"] = sourceTagToPreserve;
        }

        if (sourceId !== undefined) {
            queryParameters["sourceId"] = sourceId;
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: MultipleDeleteResult;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum WebHooksApiApiKeys {}

export class WebHooksApi {
    protected basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications: any = {
        default: <Authentication>new VoidAuth()
    };

    constructor(basePath?: string);
    constructor(
        basePathOrUsername: string,
        password?: string,
        basePath?: string
    ) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    public setApiKey(key: WebHooksApiApiKeys, value: string) {
        this.authentications[WebHooksApiApiKeys[key]].apiKey = value;
    }
    /**
     * Acknowledge a previously-deferred web hook
     * Acknowledges a previously-deferred web hook with a given ID.  Acknowledging a previously-POSTed web hook will cause the next, if any, to be sent.
     * @param id ID of the web hook to be acknowledged.
     * @param acknowledgement The details of the acknowledgement.
     * @param xMagdaSession Magda internal session id
     */
    public ack(
        id: string,
        acknowledgement: WebHookAcknowledgement,
        xMagdaSession: string
    ): Promise<{
        response: http.IncomingMessage;
        body: WebHookAcknowledgementResponse;
    }> {
        const localVarPath =
            this.basePath +
            "/hooks/{id}/ack".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling ack."
            );
        }

        // verify required parameter 'acknowledgement' is not null or undefined
        if (acknowledgement === null || acknowledgement === undefined) {
            throw new Error(
                "Required parameter acknowledgement was null or undefined when calling ack."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling ack."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: acknowledgement
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: WebHookAcknowledgementResponse;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Create a new web hook
     *
     * @param hook The definition of the new web hook.
     * @param xMagdaSession Magda internal session id
     */
    public create(
        hook: WebHook,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: WebHook }> {
        const localVarPath = this.basePath + "/hooks";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'hook' is not null or undefined
        if (hook === null || hook === undefined) {
            throw new Error(
                "Required parameter hook was null or undefined when calling create."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling create."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: hook
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebHook }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Delete a web hook
     *
     * @param hookId ID of the web hook to delete.
     * @param xMagdaSession Magda internal session id
     */
    public deleteById(
        hookId: string,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: DeleteResult }> {
        const localVarPath =
            this.basePath +
            "/hooks/{hookId}".replace("{" + "hookId" + "}", String(hookId));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'hookId' is not null or undefined
        if (hookId === null || hookId === undefined) {
            throw new Error(
                "Required parameter hookId was null or undefined when calling deleteById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling deleteById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: DeleteResult;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a list of all web hooks
     *
     * @param xMagdaSession Magda internal session id
     */
    public getAll(
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: Array<WebHook> }> {
        const localVarPath = this.basePath + "/hooks";
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling getAll."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{
            response: http.IncomingMessage;
            body: Array<WebHook>;
        }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (
                        response.statusCode >= 200 &&
                        response.statusCode <= 299
                    ) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
    /**
     * Get a web hook by ID
     *
     * @param id ID of the web hook to be fetched.
     * @param xMagdaSession Magda internal session id
     */
    public getById(
        id: string,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: WebHook }> {
        const localVarPath =
            this.basePath + "/hooks/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling getById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling getById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebHook }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
    /**
     * Modify a web hook by ID
     * Modifies the web hook with a given ID.  If a web hook with the ID does not yet exist, it is created.
     * @param id ID of the aspect to be saved.
     * @param hook The web hook to save.
     * @param xMagdaSession Magda internal session id
     */
    public putById(
        id: string,
        hook: WebHook,
        xMagdaSession: string
    ): Promise<{ response: http.IncomingMessage; body: WebHook }> {
        const localVarPath =
            this.basePath + "/hooks/{id}".replace("{" + "id" + "}", String(id));
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error(
                "Required parameter id was null or undefined when calling putById."
            );
        }

        // verify required parameter 'hook' is not null or undefined
        if (hook === null || hook === undefined) {
            throw new Error(
                "Required parameter hook was null or undefined when calling putById."
            );
        }

        // verify required parameter 'xMagdaSession' is not null or undefined
        if (xMagdaSession === null || xMagdaSession === undefined) {
            throw new Error(
                "Required parameter xMagdaSession was null or undefined when calling putById."
            );
        }

        headerParams["X-Magda-Session"] = xMagdaSession;

        let useFormData = false;

        let requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: hook
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.IncomingMessage; body: WebHook }>(
            (resolve, reject) => {
                request(requestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (
                            response.statusCode >= 200 &&
                            response.statusCode <= 299
                        ) {
                            resolve({ response: response, body: body });
                        } else {
                            reject({ response: response, body: body });
                        }
                    }
                });
            }
        );
    }
}
